<?php

/**
 * Provides the following fields:
 *
 * - Maps point
 * - Maps polygon
 * - Maps polyline
 * - Maps countries (click on a country to select)
 * - Maps combination (combination of the above).
 */
/**
 * Does not implement the following (amongst others) hook_field_* hooks.
 * This is for my benefit only, and will be removed.
 *
 * hook_field_load().
 * hook_field_delete().
 * hook_field_access().
 * hook_field_presave().
 * hook_field_settings_form().
 */


/**
 * Implementation of hook_theme().
 */
function gm3_field_theme(){
  return array(
    'gm3_point_text' => array(
      'variables' => array(
        'data' => array()
      )
    ),
    'gm3_point_text_lat' => array(
      'variables' => array(
        'data' => array()
      )
    ),
    'gm3_point_text_lon' => array(
      'variables' => array(
        'data' => array()
      )
    ),
    'gm3_polygon_text' => array(
      'variables' => array(
        'data' => array()
      )
    ),
    'gm3_polyline_text' => array(
      'variables' => array(
        'data' => array()
      )
    ),
    'gm3_rectangle_text' => array(
      'variables' => array(
        'data' => array()
      )
    ),
    'point_text' => array(
      'variables' => array(
        'data' => array()
      )
    ),
    'polygon_text' => array(
      'variables' => array(
        'data' => array()
      )
    ),
    'polyline_text' => array(
      'variables' => array(
        'data' => array()
      )
    ),
    'rectangle_text' => array(
      'variables' => array(
        'data' => array()
      )
    )
  );
}

/**
 * Given a WKT string representing a polygon (e.g. from an input textbox),
 * return an array of polygons, each of which being an array of coordinates.
 * Used to generate settings for the js map.
 */
function _gm3_field_get_latlngs_from_polygon_string($value) {
  module_load_include('functions.inc', 'gm3');
  $polygons = [];
  $split_value = $value ? preg_split("/\r\n|\n|\r/", $value) : [];
  foreach($split_value as $string) {
    $polygons = array_merge($polygons, gm3_convert_polygon_string($string));
  }
  return $polygons;
}

/**
 * Implementation of hook_field_info().
 */
function gm3_field_field_info(){
  $options = array(
    'gm3_point' => 'Point',
    'gm3_polygon' => 'Polygon',
    'gm3_polyline' => 'Polyline',
    'gm3_rectangle' => 'Rectangle'
  );
  drupal_alter('gm3_combination_field_options', $options);
  return array(
    'gm3_point' => array(
      'label' => t('Geo: Point'),
      'description' => t('This field stores latitude/longitude pairs.'),
      'default_widget' => 'gm3_point_gm3',
      'default_formatter' => 'gm3_entity_map'
    ),
    'gm3_polygon' => array(
      'label' => t('Geo: Polygon'),
      'description' => t('This field stores geographical polygons/areas.'),
      'default_widget' => 'gm3_polygon_gm3',
      'default_formatter' => 'gm3_entity_map'
    ),
    'gm3_polyline' => array(
      'label' => t('Geo: Line'),
      'description' => t('This field stores geographical lines.'),
      'default_widget' => 'gm3_polyline_gm3',
      'default_formatter' => 'gm3_entity_map'
    ),
    'gm3_rectangle' => array(
      'label' => t('Geo: Rectangle'),
      'description' => t('This field stores a rectangle.'),
      'default_widget' => 'gm3_rectangle_gm3',
      'default_formatter' => 'gm3_entity_map'
    ),
    'gm3_combination' => array(
      'label' => t('Geo: Super-combo'),
      'description' => t('Allows for the storage of any geographical data. Including points, lines, areas, lists of regions, and addresses'),
      'settings' => $options,
      'default_widget' => 'gm3_combination_gm3',
      'default_formatter' => 'gm3_entity_map'
    )
  );
}

/**
 * Implementation of hook_field_settings_form().
 */
function gm3_field_field_settings_form($field, $instance, $has_data){
  $form = array(
    'allow_text_entry' => array(
      '#type' => 'radios',
      '#title' => t('Allow text entry'),
      '#options' => array(
        'No',
        'Yes'
      ),
      '#default_value' => isset($field['settings']['allow_text_entry']) ? $field['settings']['allow_text_entry'] : ($field['type'] == 'gm3_point' && $field['cardinality'] == 1) ? 1 : 0,
      '#required' => TRUE,
      '#description' => t('Select whether a user can also enter data using a text field')
    )
  );
  switch($field['type']){
    case 'gm3_combination':
      $options = array(
        'gm3_point' => 'Point',
        'gm3_polygon' => 'Polygon',
        'gm3_polyline' => 'Polyline',
        'gm3_rectangle' => 'Rectangle'
      );
      drupal_alter('gm3_combination_field_options', $options);
      $form['field_types'] = array(
        '#type' => 'select',
        '#title' => t('Field types'),
        '#options' => $options,
        '#multiple' => TRUE,
        '#default_value' => isset($field['settings']['field_types']) ? $field['settings']['field_types'] : $options, // Default to all
        '#required' => TRUE,
        '#description' => t('Select the types of Widget you would like to use')
      );
  }
  return $form;
}

/**
 * Implements hook_form_alter().
 *
 * If we are adding a new entity we pass of to entityconnect_add_form_alter
 * if we are returning to the parent form we hand off to
 * entityconnect_return_form_alter.
 */
function gm3_field_form_alter(&$form, &$form_state, $form_id){
  // Theme the entity connect elements if any are present
  if(function_exists('_entityconnect_get_ref_fields')){
    foreach(_entityconnect_get_ref_fields() as $field_name => $field){
      // What type of entity are we to load.
      switch($field['type']){
        case 'node_reference':
          $entity_type = 'node';
          break;
        case 'user_reference':
          $entity_type = 'user';
          break;
      }
      if(isset($form[$field_name])){
        if(isset($form[$field_name]['preview'])){
          $add_libraries = FALSE;
          switch($entity_type){
            case 'node':
              $types = array_filter($field['settings']['referenceable_types']);
              foreach($types as $bundle){
                $instances = field_info_instances($entity_type, $bundle);
                foreach($instances as $instance){
                  if(@isset($instance['display']['entityconnectpreview']['module']) && $instance['display']['entityconnectpreview']['module'] == 'gm3_field'){
                    $add_libraries = TRUE;
                    break 2;
                  }
                }
              }
              break;
            case 'user':
              break;
          }
          if($add_libraries){
            // We add all of the libraries, just to be safe.
            $form[$field_name]['preview']['#attached'] = array(
              'library' => array(
                array(
                  'gm3',
                  'gm3'
                ),
                array(
                  'gm3',
                  'gm3.point'
                ),
                array(
                  'gm3',
                  'gm3.polygon'
                ),
                array(
                  'gm3',
                  'gm3.rectangle'
                ),
                array(
                  'gm3',
                  'gm3.polyline'
                )
              )
            );
          }
        }
      }
    }
  }
}

/**
 * Implements hook_feeds_processor_targets_alter().
 */
function gm3_field_feeds_processor_targets_alter(&$targets, $entity_type, $bundle_name){
  $map_types = array(
    'gm3_point',
    'gm3_polygon',
    'gm3_polyline',
    'gm3_rectangle',
    'gm3_combination',
    'gm3_region' // Should be in the gm3_region_field module, but it's easy here!
  );
  foreach(field_info_instances($entity_type, $bundle_name) as $name => $instance){
    $info = field_info_field($name);
    if(in_array($info['type'], $map_types)){
      $targets[$name] = array(
        'name' => check_plain($instance['label']),
        'callback' => 'gm3_field_feeds_set_target_text',
        'description' => t('The @label field of the node.', array(
          '@label' => $instance['label']
        ))
      );
    }
  }
}

/**
 * Callback to set the value for a GM3 field.
 */
function gm3_field_feeds_set_target_text($source, $entity, $target, $value){
  $entity_type = strtolower(get_class($source->importer->processor));
  if(($processor_location = strpos($entity_type, 'processor')) > 0){
    $entity_type = substr($entity_type, 0, $processor_location);
  }
  if(substr($entity_type, 0, 5) == 'feeds'){
    $entity_type = substr($entity_type, 5);
  }
  if(!entity_get_info($entity_type)){
    $entity_type = 'node';
  }
  if(is_array($value)){
    $value = $value[0];
  }
  $field = isset($entity->$target) ? $entity->$target : array();
  $lang = field_language($entity_type, $entity, $target);
  $field[$lang][] = $value;
  $entity->{$target} = $field;
}

/**
 * Helper function to get values from a polygon/polyline/rectangle string
 */
function _gm3_field_get_array_from_polygon_string($value, $poly_type){
  $items = [];

  if(is_array($value) || strlen(trim($value))){
    if(is_string($value)){
      $value = preg_split("/\n/", $value);
    }
    foreach($value as $poly){
      $items[] = [
        $poly_type => $poly
      ];
    }
  }

  return $items;
}

/**
 * Helper function to get values from a points string
 */
function _gm3_field_get_array_from_points_string($value, &$items = Null, $type = FALSE){
  if(!isset($items)) {
    $items = [];
  }

  if(is_array($value) || strlen(trim($value))){
    if(is_string($value)){
      $value = preg_split("/[\n\r|]+/", $value);
    }
    foreach($value as $lat_lng){
      if(preg_match('/[a-zA-Z][a-zA-Z][0-9]/', $lat_lng)){
        try{
          if(($path = libraries_get_path('gridrefutils')) != FALSE && file_exists("$path/gridrefutils.php")){
            include_once "$path/gridrefutils.php";
          }
          $grutoolbox = Grid_Ref_Utils::toolbox();
          // convert to a numeric reference
          $uk_grid_numbers = $grutoolbox->get_UK_grid_nums($lat_lng);
          // convert to global latitude/longitude
          $grid_ref = $grutoolbox->grid_to_lat_long($uk_grid_numbers, $grutoolbox->COORDS_GPS_UK, $grutoolbox->HTML);
          // Remove deg symbol.
          $lat_lng = str_replace('&deg;', '', $grid_ref);
        }
        catch(Exception $e){
          // We've experienced an error. Give an error message, and do nothing
          // more.
          drupal_set_message(t('Unable to convert grid reference %grid_ref', array('%grid_ref'=> $lat_lng)), 'error', FALSE);
          break;
        }
      }

      $lat_lng = preg_replace('/[)(]/', '', $lat_lng);
      $lat_lng = explode(", ", $lat_lng);
      if(count($lat_lng) == 1){
        $lat_lng = explode(",", $lat_lng[0]);
      }
      $lat_lng = array(
        'latitude' => $lat_lng[0],
        'longitude' => $lat_lng[1]
      );
      if($type){
        $lat_lng['gm3_type'] = $type;
      }
      $items[] = $lat_lng;
    }
  }
  return $items;
}

function _gm3_field_combination_hook($field_type) {
  return module_invoke_all("gm3_field_combination_info")[$field_type];
}

function _gm3_field_combination_invoke($field_type, $hook_name, $args) {
  return call_user_func_array(_gm3_field_combination_hook($field_type)[$hook_name], $args);
}

function gm3_field_combination_widget_validate(&$element, &$form_state) {
  $field = field_widget_field($element, $form_state);
  $types = $field['settings']['field_types'];
  $items = [];

  foreach($types as $gm3_type) {
    // $gm3_type is the name of the field types this widget supports;
    // it's the shape name with with gm3_ on the beginning
    $type = substr($gm3_type, 4);

    $storage = _gm3_field_form_to_storage($element[$type], $gm3_type);

    if(!isset($storage)) {
      $storage = _gm3_field_combination_invoke($gm3_type, 'form_to_storage', [$element[$type]]);
    }

    $storage = array_map(
      // Have to add the gm3_type value to combo fields so we know where to
      // look for data when reading back
      function($item) use ($type) { $item['gm3_type'] = $type; return $item; },
      $storage
    );

    _gm3_field_set_map_items($element['map'], $type, $storage);

    $items = array_merge($items, $storage);
  }

  form_set_value($element, $items, $form_state);
}

function gm3_field_widget_validate(&$element, &$form_state){
  $field = field_widget_field($element, $form_state);
  $type = $field['type'];

  // The input element name should be hardcoded as 'field' in the widget definition
  $input_element = $element['field'];

  $items = _gm3_field_form_to_storage($input_element, $type);

  form_set_value($element, $items, $form_state);

  _gm3_field_set_map_items($element['map'], $type, $items);
}

function _gm3_field_set_map_items(&$map, $type, $items) {
  switch($type) {
    case 'gm3_point':
    case 'point':
      $map['#gm3']['libraries']['point'] = gm3_field_js_point_settings($items, true);
      break;
    case 'gm3_polyline':
    case 'polyline':
      $map['#gm3']['libraries']['polyline'] = [
        'polylines' => gm3_field_js_poly_settings($items, 'polyline')
      ];
      break;
    case 'gm3_polygon':
    case 'polygon':
      $map['#gm3']['libraries']['polygon'] = [
        'polygons' => gm3_field_js_poly_settings($items, 'polygon')
      ];
      break;
    case 'gm3_rectangle':
    case 'rectangle':
      $map['#gm3']['libraries']['rectangle'] = [
        'rectangles' => gm3_field_js_poly_settings($items, 'rectangle')
      ];
      break;
    default:
      // Todo: Should this call the actual specific function?
      $hooks = _gm3_field_combination_hook("gm3_$type") ?? _gm3_field_combination_hook("$type");

      $library = $hooks['name'];
      $settings_fn = $hooks['map_settings'];

      $map['#gm3']['libraries'][$library] = $settings_fn($items);
      break;
  }
}

function _gm3_field_form_to_storage($element, $type) {
  $value = $element['#value'];

  switch($type){
    case 'gm3_point':
      return _gm3_field_get_array_from_points_string($value);
    case 'gm3_polyline':
      return _gm3_field_get_array_from_polygon_string($value, 'polyline');
    case 'gm3_polygon':
      return _gm3_field_get_array_from_polygon_string($value, 'polygon');
    case 'gm3_rectangle':
      return _gm3_field_get_array_from_polygon_string($value, 'rectangle');
  }

  return null;
}

/**
 * Implementation of hook_field_widget_info().
 */
function gm3_field_field_widget_info(){
  return array(
    'gm3_point_gm3' => array(
      'label' => t('Geo: Point Map'),
      'description' => t('Latitude/Longitude pairs entered by clicking on a map.'),
      'field types' => array(
        'gm3_point'
      ),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
        'default value' => FIELD_BEHAVIOR_DEFAULT
      )
    ),
    'gm3_point_text' => array(
      'label' => t('Geo: Point text'),
      'description' => t('Latitude/Longitude pairs entered into a text box'),
      'field types' => array(
        'gm3_point'
      )
    ),
    'gm3_polygon_gm3' => array(
      'label' => t('Geo: Polygon Map'),
      'description' => t('Many Latitude/Longitude pairs which combine to form a shape, entered on a map.'),
      'field types' => array(
        'gm3_polygon'
      ),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
        'default value' => FIELD_BEHAVIOR_DEFAULT
      )
    ),
    'gm3_polygon_text' => array(
      'label' => t('Geo: Polygon text'),
      'description' => t('Many Latitude/Longitude pairs which combine to form a shape, entered in a text box.'),
      'field types' => array(
        'gm3_polygon'
      )
    ),
    'gm3_rectangle_gm3' => array(
      'label' => t('Geo: Rectangle Map'),
      'description' => t('Two Latitude/Longitude pairs that combine to form a rectangle, entered on a map.'),
      'field types' => array(
        'gm3_rectangle'
      ),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
        'default value' => FIELD_BEHAVIOR_DEFAULT
      )
    ),
    'gm3_rectangle_text' => array(
      'label' => t('Geo: Rectangle text'),
      'description' => t('Two Latitude/Longitude pairs that combine to form a rectangle, entered in a text box.'),
      'field types' => array(
        'gm3_rectangle'
      )
    ),
    'gm3_polyline_gm3' => array(
      'label' => t('Geo: Polyline Map'),
      'description' => t('Many Latitude/Longitude pairs which combine to form a line, entered on a map.'),
      'field types' => array(
        'gm3_polyline'
      ),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
        'default value' => FIELD_BEHAVIOR_DEFAULT
      )
    ),
    'gm3_polyline_text' => array(
      'label' => t('Geo: Polygon text'),
      'description' => t('Many Latitude/Longitude pairs which combine to form a shape, entered in a text box.'),
      'field types' => array(
        'gm3_polygon'
      )
    ),
    'gm3_combination_gm3' => array(
      'label' => t('Geo: Combination Map'),
      'description' => t('Whatever you would like, on a map.'),
      'field types' => array(
        'gm3_combination'
      ),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
        'default value' => FIELD_BEHAVIOR_DEFAULT
      )
    ),
    'gm3_combination_text' => array(
      'label' => t('Geo: Combination text'),
      'description' => t('Whatever you would like, in a text box.'),
      'field types' => array(
        'gm3_combination'
      )
    )
  );
}

/**
 * Implements hook_field_validate().
 */
function gm3_field_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors){
  if(function_exists("{$field['type']}_items_validate")){
    $func = "{$field['type']}_items_validate";
    $func($items, $field['field_name'], $errors);
  }
}

/**
 * Validation functions
 * -----------------------------------------------------------------------------
 */
function gm3_polygon_items_validate($items, $field_name, &$errors){
  if(isset($items['map']['map']) && is_string($items['map']['map'])){
    $polygons = preg_split('/[\r\n]+/', $items['map']['map']);
    foreach($polygons as $polygon){
      if($polygon && !gm3_is_valid_polygon($polygon)){
        $errors[$field_name][LANGUAGE_NONE][0][] = array(
          'error' => 'gm3_invalid_data',
          'message' => t('Invalid map data has been entered. Please reload this page before resubmitting.')
        );
      }
    }
  }
}

function gm3_combination_items_validate($items, $field_name, &$errors){
  foreach($items as $item){
    if(is_string($item)){
      $lines = preg_split("/[\n\r]+/", $item);
      foreach($lines as $line){
        $first_colon_pos = strpos($line, ':');
        $type = substr($line, 0, $first_colon_pos);
        $rest = substr($line, $first_colon_pos + 1);
        $func = false;
        if(function_exists($type . '_items_validate')){
          $func = $type . '_items_validate';
        }else if(function_exists("gm3_{$type}_items_validate")){
          $func = "gm3_{$type}_items_validate";
        }
        if($func){
          $func(array(
            $rest
          ), $field_name, $errors);
        }
      }
    }
  }
}

/**
 * Ensure the text for a single polygon is valid
 */
function gm3_is_valid_polygon($polygon){
  // Load the Library.
  gm3_load_geophp();
  $wkt_reader = new WKT();
  return $wkt_reader->read($polygon, TRUE);
}

function gm3_point_items_validate($items, $field_name, &$errors){}

/**
 * Implements hook_field_is_empty().
 */
function gm3_field_field_is_empty($item, $field){
  switch($field['type']){
    case 'gm3_point':
      return !isset($item['latitude']);
    case 'gm3_polygon':
      return !isset($item['polygon']);
    case 'gm3_polyline':
      return !isset($item['polyline']);
    case 'gm3_rectangle':
      return !isset($item['rectangle']);
    case 'gm3_combination':
      if(is_array($item)){
        if(isset($item['map']['children'])){
          foreach($item['map']['children'] as $type => $value){
            if(is_array($value)){
              if(count($value)){return FALSE;}
            }else if(is_string($value)){
              if(strlen(trim($value))){return FALSE;}
            }
          }
        }else{
          $non_empty = array_filter($item, function ($i){
            return $i !== NULL;
          });
          return !count($non_empty);
        }
        return TRUE;
      }else{
        // This is for the benefit of the Feeds module.
        return !strlen(trim($item));
      }
  }
}

/**
 * Implements hook_field_formatter_info().
 *
 * FIXME - We need to add settings to these formatter types to allow the display
 * of the map to be altered.
 */
function gm3_field_field_formatter_info(){
  return array(
    'gm3_entity_map' => array(
      'label' => t('Geo field single map.'),
      'description' => t('Displays all the data from a single field on a single map.'),
      'field types' => array(
        'gm3_point',
        'gm3_polygon',
        'gm3_polyline',
        'gm3_combination'
      ),
      'settings' => array(
        'display_convex_hull' => FALSE
      )
    ),
    'gm3_field_map' => array(
      'label' => t('Geo field map per field.'),
      'description' => t('Displays all the data from fields also selected to use this display type on a single map.'),
      'field types' => array(
        'gm3_point',
        'gm3_polygon',
        'gm3_polyline',
        'gm3_combination'
      ),
      'settings' => array(
        'display_convex_hull' => FALSE
      )
    ),
    'gm3_text' => array(
      'label' => t('Geo field text.'),
      'field types' => array(
        'gm3_point',
        'gm3_polygon',
        'gm3_polyline',
        'gm3_combination'
      )
    ),
    'gm3_text_lat' => array(
      'label' => t('Geo field text (latitude).'),
      'field types' => array(
        'gm3_point',
        'gm3_polygon',
        'gm3_polyline',
        'gm3_combination'
      )
    ),
    'gm3_text_lon' => array(
      'label' => t('Geo field text (longitude).'),
      'field types' => array(
        'gm3_point',
        'gm3_polygon',
        'gm3_polyline',
        'gm3_combination'
      )
    )
  );
}

/**
 * Implements hook_field_formatter_settings_form().
 */
function gm3_field_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state){
  switch($instance['display'][$view_mode]['type']){
    case 'gm3_entity_map':
    case 'gm3_field_map':
      return array(
        'display_convex_hull' => array(
          '#title' => t('Display convex hull of points.'),
          '#type' => 'radios',
          '#required' => TRUE,
          '#default_value' => isset($instance['display'][$view_mode]['settings']['display_convex_hull']) ? $instance['display'][$view_mode]['settings']['display_convex_hull'] : 0,
          '#options' => array(
            t('No'),
            t('Yes')
          )
        )
      );
  }
}

/**
 * Implements hook_field_formatter_settings_summary().
 */
function gm3_field_field_formatter_settings_summary($field, $instance, $view_mode){
  switch($instance['display'][$view_mode]['type']){
    case 'gm3_entity_map':
    case 'gm3_field_map':
      $summary = array();
      if(!isset($instance['display'][$view_mode]['settings']['display_convex_hull']) || $instance['display'][$view_mode]['settings']['display_convex_hull']){
        $summary[] = t('Display convex hull of points on the map.');
      }else{
        $summary[] = t('No convex hull will be displayed.');
      }
      return implode('<br />', $summary);
  }
}

/**
 * Themes for field types.
 */
function theme_gm3_point_text($variables){
  return array(
    '#markup' => t('Longitude: %longitude, Latitude: %latitude', array(
      '%longitude' => $variables['data']['longitude'],
      '%latitude' => $variables['data']['latitude']
    ))
  );
}

function theme_gm3_point_text_lat($variables){
  return array(
    '#markup' => t('%latitude', array(
      '%latitude' => $variables['data']['latitude']
    ))
  );
}

function theme_gm3_point_text_lon($variables){
  return array(
    '#markup' => t('%longitude', array(
      '%longitude' => $variables['data']['longitude']
    ))
  );
}

/**
 * Themes for field types.
 */
function theme_gm3_polygon_text($variables){
  return array(
    '#markup' => $variables['data']['polygon']
  );
}

/**
 * Themes for field types.
 */
function theme_gm3_polyline_text($variables){
  return array(
    '#markup' => $variables['data']['polyline']
  );
}

/**
 * Themes for field types.
 *
 * Note, this is A LOT simpler than renaming every instance of "polygon" to
 * "gm3_polygon", although I may do that in the future.
 */
function theme_gm3_rectangle_text($variables){
  return array(
    '#markup' => $variables['data']['rectangle']
  );
}

function theme_point_text($variables){
  return theme('gm3_point_text', $variables);
}

function theme_polygon_text($variables){
  return theme('gm3_polygon_text', $variables);
}

function theme_polyline_text($variables){
  return theme('gm3_polyline_text', $variables);
}

function theme_rectangle_text($variables){
  return theme('gm3_rectangle_text', $variables);
}

/**
 * Implements hook_field_formatter_view().
 *
 * FIXME - Still need to do the field/entity formats properly (so that an entity
 * map will show all the fields set as "entity_map" on that entity.
 */
function gm3_field_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display){
  switch($display['type']){
    case 'gm3_entity_map':
      // Set an ID based on the entity.
      $entity_info = entity_get_info($entity_type);
      $id = "gm3_map-" . (!empty($entity_info['entity keys']['bundle']) ? $entity->{$entity_info['entity keys']['bundle']} : 'bundle') . "-" . $entity->{$entity_info['entity keys']['id']};
      break;
    case 'gm3_field_map':
      // Setting the ID here is easy, as we can simply use the field ID.
      $id = $instance['field_name'];
      break;
    case 'gm3_text_lat':
      $elements = array();
      switch($field['type']){
        case 'gm3_combination':
          foreach($items as $item){
            $elements[] = theme($item['gm3_type'] . '_text_lat', array(
              'data' => $item
            ));
          }
          break;
        default:
          foreach($items as $item){
            $elements[] = theme($field['type'] . '_text_lat', array(
              'data' => $item
            ));
          }
          break;
      }
      return $elements;
      break;
    case 'gm3_text_lon':
      $elements = array();
      switch($field['type']){
        case 'gm3_combination':
          foreach($items as $item){
            $elements[] = theme($item['gm3_type'] . '_text_lon', array(
              'data' => $item
            ));
          }
          break;
        default:
          foreach($items as $item){
            $elements[] = theme($field['type'] . '_text_lon', array(
              'data' => $item
            ));
          }
          break;
      }
      return $elements;
      break;
    case 'gm3_text':
    default:
      $elements = array();
      switch($field['type']){
        case 'gm3_combination':
          foreach($items as $item){
            $elements[] = theme($item['gm3_type'] . '_text', array(
              'data' => $item
            ));
          }
          break;
        default:
          foreach($items as $item){
            $elements[] = theme($field['type'] . '_text', array(
              'data' => $item
            ));
          }
          break;
      }
      return $elements;
  }
  switch($field['type']){
    case 'gm3_point':
      if(count($items)){
        // Set the items as not being editable.
        foreach(array_keys($items) as $key){
          $items[$key]['editable'] = FALSE;
          $items[$key]['colour'] = variable_get('gm3_default_point_colour', 0);
          if(!isset($items[$key]['content'])){
            $items[$key]['content'] = 'Latitude: ' . $items[$key]['latitude'] . '<br/>Longitude: ' . $items[$key]['longitude'];
          }
        }

        module_load_include('theme.inc', 'gm3');
        $element = gm3_get_map(array(
            'id' => $id,
            'libraries' => array(
              'point' => array(
                'points' => $items,
                'convexhull' => $display['settings']['display_convex_hull']
              )
            )
        ));
      }
      break;
    case 'gm3_rectangle':
    case 'gm3_polyline':
    case 'gm3_polygon':
      module_load_include('functions.inc', 'gm3');
      if(count($items)){
        $polys = array();
        foreach($items as $key => $item){
          $array_to_pop = gm3_convert_polygon_string($item[substr($field['type'], 4)]);
          $polys[] = array(
            substr($field['type'], 4) => array_pop($array_to_pop),
            'editable' => FALSE
          );
        }
        module_load_include('theme.inc', 'gm3');
        $element = gm3_get_map(array(
            'id' => $id,
            'libraries' => array(
              'polygon' => array(),
              substr($field['type'], 4) => array(
                substr($field['type'], 4) . 's' => $polys
              )
            )
        ));
      }
      break;
    case 'gm3_combination':
      $map = array(
        'id' => $id,
        'libraries' => array(
          'point' => array(
            'points' => array(),
            'convexhull' => $display['settings']['display_convex_hull']
          ),
          'polygon' => array(
            'polygons' => array()
          ),
          'polyline' => array(
            'polylines' => array()
          ),
          'rectangle' => array(
            'rectangles' => array()
          )
        )
      );
      $display_map = FALSE;
      module_load_include('functions.inc', 'gm3');
      foreach($items as $item){
        switch($item['gm3_type']){
          case 'rectangle':
          case 'polygon':
          case 'polyline':
            $shape = gm3_convert_polygon_string($item[$item['gm3_type']]);
            if(is_array($shape)){
              $map['libraries'][$item['gm3_type']][$item['gm3_type'] . 's'][] = array(
                $item['gm3_type'] => array_pop($shape),
                'editable' => FALSE
              );
              $display_map = TRUE;
            }
            break;
          case 'point':
            $map['libraries']['point']['points'][] = array(
              'latitude' => $item['latitude'],
              'longitude' => $item['longitude'],
              'colour' => variable_get('gm3_default_point_colour', 0),
              'editable' => FALSE
            );
            $display_map = TRUE;
            break;
          default:
            // Call hook_TYPE_map_alter functions
            $alter_hook = "{$item['gm3_type']}_map";
            drupal_alter($alter_hook, $map, $item);
            $display_map = isset($map['libraries'][$item['gm3_type']]);
            break;
        }
      }

      if($display_map){
        module_load_include('theme.inc', 'gm3');
        $element = gm3_get_map($map);
      }
      break;
    default:
      // Here we have a field that was not defined by this module, we use the
      // name of the module, plus the name of the type plus view to get the name
      // of the function to call
      // "{$field['module']}_{$field['type']}_view()"
      if(function_exists("{$field['module']}_{$field['type']}_view")){
        $function_name = "{$field['module']}_{$field['type']}_view";
        $element = $function_name($entity_type, $entity, $field, $instance, $langcode, $items, $display, $id);
      }
      break;
  }
  if(isset($element) && $element){return array(
      $element
    );}
}

/**
 * Implementation of hook_field_display_alter().
 */
function gm3_field_field_display_alter(&$display, $context){
  if($display['type'] == 'gm3_entity_map'){
    $display['label'] = 'hidden';
  }
}

/**
 * Helper function to convert an array to a points string.
 */
function _gm3_field_get_points_string_from_array($items){
  $item_length = count($items);
  for($i = 0; $i < $item_length; $i++){
    $items[$i] = "({$items[$i]['latitude']}, {$items[$i]['longitude']})";
  }
  return implode("|", $items);
}

/**
 * Generate the js settings for the point library
 */
function gm3_field_js_point_settings($items, $editable = false){
  // Todo: Must we mark each individual item editable? Can't we just do it on the module settings?
  foreach($items as $key => $item){
    $items[$key]['editable'] = $editable;
  }

  return [
    'points' => $items,
    'module' => 'gm3'
  ];
}

function gm3_field_js_poly_settings($items, $key) {
  module_load_include('functions.inc', 'gm3');

  foreach($items as $ix => $item) {
    $items[$ix] = gm3_convert_polygon_string($item[$key])[0];
  }

  return $items;
}

/**
 * Generate the field element for the point input textbox
 */
function gm3_field_point_field($id, $items, $allow_text_entry){
  return array(
    '#title' => 'point',
    '#attributes' => array(
      'class' => array(
        $id . '-point'
      ),
      'placeholder' => '(' . t('Decimal latitude') . ', ' . t('Decimal longitude') . ') e.g. (51.49679, -0.17792)'
    ),
    '#default_value' => _gm3_field_get_points_string_from_array($items),
    '#type' => $allow_text_entry ? 'textfield' : 'hidden',
    '#maxlength' => 10000000
  );
}

function gm3_field_input_element($id, $items, $allow_text_entry, $type) {
  switch($type){
    case 'gm3_point_gm3':
      return gm3_field_point_field($id, $items, $allow_text_entry);
    case 'gm3_polyline_gm3':
      return gm3_field_poly_field(
        $id,
        $items,
        $allow_text_entry,
        'polyline'
      );
    case 'gm3_polygon_gm3':
      return gm3_field_poly_field(
        $id,
        $items,
        $allow_text_entry,
        'polygon'
      );
    case 'gm3_rectangle_gm3':
      return gm3_field_poly_field(
        $id,
        $items,
        $allow_text_entry,
        'rectangle'
      );
  }

  return null;
}

/**
 * Generate the field element for the polygon input textareas
 */
function gm3_field_poly_field($id, $items, $allow_text_entry, $poly_type){
  // Polygon field structure is [ 'polygon_type' => 'WKT String' ]
  $items = array_map(
    function($item) use ($poly_type) { return $item[$poly_type]; },
    $items
  );

  return [
    '#type' => $allow_text_entry ? 'textarea' : 'hidden',
    '#title' => $poly_type,
    '#maxlength' => 10000000,
    '#attributes' => array(
      'class' => array(
        $id . '-' . $poly_type
      )
    ),
    '#default_value' => implode('\n', $items)
  ];
}

/**
 * Generate generic map settings
 */
function gm3_field_map_js_settings($id, $max_objects = -1, $libraries = []) {
  return [
    'id' => $id,
    'libraries' => $libraries,
    'settings' => [
      'max_objects' => $max_objects ?: -1
    ],
    'tools' => true
  ];
}

function gm3_field_create_widget(&$element, $items, $input_field, $type, $cardinality) {
  // We need to add a GM3 map to the page.
  // We'll also need some additional JS to record the points and save them
  // actually into a form element.
  $element += array(
    '#type' => 'fieldset',
    '#attributes' => array(
      'class' => array(
        'gm3_fieldset'
      )
    ),
    // Use the element_validate function to convert the field value
    // to the structure used in the database
    '#element_validate' => array(
      'gm3_field_widget_validate',
    ),
    'map' => gm3_get_map(
      // Todo: Is this really needed?
      gm3_field_map_js_settings(
        $element['#field_name'],
        $cardinality
      )
    ),
    'field' => $input_field
  );

  _gm3_field_set_map_items($element['map'], $type, $items);

  return $element;
}

/**
 * Return the form for a single field widget.
 * We need to extend the $element param to make it into the widget we want, and return that.
 *
 * Implements hook_field_widget_form().
 *
 * @param Array $form A structured array containing the elements and properties of the form where widgets are being attached to.
 * @param Array $form_state The form settings - see https://api.drupal.org/api/drupal/includes%21form.inc/function/drupal_build_form/7.x
 * @param Array $field The underlying field definition - see https://api.drupal.org/api/drupal/modules%21field%21field.module/group/field/7.x
 * @param Array $instance The field instance - see https://api.drupal.org/api/drupal/modules%21field%21field.module/group/field/7.x
 * @param String $langcode The language associated with $items.
 * @param Array $items Array of default values for this field.
 * @param Number $delta The order of this item in the array of subelements (0, 1, 2, etc).
 * @param Array $element A form element array containing basic properties for the widget - see https://api.drupal.org/api/drupal/modules%21field%21field.api.php/function/hook_field_widget_form/7.x
 */
function gm3_field_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element){
  // Data field type
  $allow_text_entry = !empty($field['settings']['allow_text_entry']) || ($field['type'] == 'gm3_point' && $field['cardinality'] == 1);

  // Load gm3_get_map
  // Todo: can we somehow have it load automatically?
  // Todo: Don't do this stuff if we haven't matched the widget
  module_load_include('theme.inc', 'gm3');

  $input_field = gm3_field_input_element(
    $element['#field_name'],
    $items,
    $allow_text_entry,
    $instance['widget']['type']
  );

  switch($instance['widget']['type']){
    case 'gm3_point_gm3':
      return gm3_field_create_widget($element, $items, $input_field, 'point', $field['cardinality']);
      break;
    case 'gm3_polyline_gm3':
      return gm3_field_create_widget($element, $items, $input_field, 'polyline', $field['cardinality']);
      break;
    case 'gm3_polygon_gm3':
      return gm3_field_create_widget($element, $items, $input_field, 'polygon', $field['cardinality']);
      break;
    case 'gm3_rectangle_gm3':
      return gm3_field_create_widget($element, $items, $input_field, 'rectangle', $field['cardinality']);
      break;
    case 'gm3_combination_gm3':
      $values = array_reduce(
        $items,
        function($carry, $item){
          $type = $item['gm3_type'];

          if (!isset($carry[$type])) {
            $carry[$type] = [$item];
          } else {
            $carry[$type][] = $item;
          }

          return $carry;
        },
        []
      );

      $map = gm3_get_map(
        // Todo: Can't this just be one function?
        gm3_field_map_js_settings(
          $element['#field_name'],
          $field['cardinality']
        )
      );

      $field_elements = [];

      foreach($field['settings']['field_types'] as $gm3_type) {
        $type = substr($gm3_type, 4);
        _gm3_field_set_map_items($map, $type, $values[$type] ?? []);

        $field_element = gm3_field_input_element(
          $element['#field_name'],
          $values[$type] ?? [],
          $allow_text_entry,
          $gm3_type . "_gm3"
        );

        if(!isset($field_element)) {
          $field_element = _gm3_field_combination_invoke(
            $gm3_type,
            'field_element',
            [$element["#field_name"], $values[$type] ?? [], $allow_text_entry]
          );
        }

        $field_elements[$type] = $field_element;
      };

      return $element + [
        '#type' => 'fieldset',
        '#attributes' => array(
          'class' => array(
            'gm3_fieldset'
          )
        ),
        // Use the element_validate function to convert the field value
        // to the structure used in the database
        '#element_validate' => array(
          // Use a different validator for the combination widget
          'gm3_field_combination_widget_validate',
        ),
        'map' => $map
      ] + $field_elements;
      break;
  }
}
